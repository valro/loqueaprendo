
#+TITLE: learn-c
#+AUTHOR: valro
#+DATE: 08/02/2020
;;#+STARTUP: showall 
--------------------------------------------------
C Programming: A Modern Approach    

   @book{king2008,
   AUTHOR = {K. N. KING},
   title = {C Programming: A Modern Approach, 2nd Edition},
   description = {C Programming: A Modern Approach, 2nd Edition (Book, 2008)},
   publisher = {W. W. Norton & Company},
   interhash = {cd0edbc77780700a9e48383807942677},
   intrahash = {7eac77c7a6942f002caf1afc6d23e181},
   year = {2008},
   month = {apr},
   isbn = {9780393979503},
   url = {https://www.directtextbook.com/isbn/9780393979503}
  }
--------------------------------------------------
* Expression Evaluation

A Partial List of C operators

|----------+---------------------+------------------+---------------|
| predence | Name                | Symbol(s)        | Associativity |
|----------+---------------------+------------------+---------------|
|        1 | increment (postfix) | ++               | left          |
|          | decrement (postfix) | --               |               |
|----------+---------------------+------------------+---------------|
|        2 | increment (prefix)  | ++               | right         |
|          | decrement (prefix)  | --               |               |
|          | unary plus          | +                |               |
|          | unary minus         | -                |               |
|----------+---------------------+------------------+---------------|
|        3 | multiplicative      | * / %            | left          |
|----------+---------------------+------------------+---------------|
|        4 | additive            | + -              | left          |
|----------+---------------------+------------------+---------------|
|        5 | assignment          | = *= /= %= += -= | right         |
|----------+---------------------+------------------+---------------|

This table (see Appendix A) has a variety of uses. Let's look one of these. 
Suppose that we run across a complicated expression such as:

#+BEGIN_SRC C
a = b += c++ - d + --e / -f
#+END_SRC
This expression would be easier to understand if there were parentheses
to show how the expression is constructed from subexpressions.
Steps:
 1. the operator with highest precedence is ++, used here as postfix, so we 
    put parentheses around ++ and its operand:
    #+BEGIN_SRC C
    a = b += (c++) - d + --e / -f;
    #+END_SRC
 2. Now we spot a prefix -- operator and a unary minus operator (both with
    predence 2)
    #+BEGIN_SRC C
    a = b += (c++) - d + (--e) / (-f); // The other minus is not a unary oper.
    #+END_SRC
 3. Next we note the / operator with predence 3.
    #+BEGIN_SRC C
    a = b += (c++) - d + ((--e) / (-f));
    #+END_SRC
 4. The expression contains two operators with predence 4, substraction
    and addition. Whenever two operators with the same predence are adjacent 
    to and operand, we've got to be careful about associativity. In this example,
    - and + are both adjacent to d, so associativity rules apply. The - and +
    operators group from left to right, so the parentheses go around the
    substraction first, then the addition.
    #+BEGIN_SRC C
    a = b += (((c++) - d) + ((--e) / (-f)));
    #+END_SRC
 5. The only remaining operators are = and +=. B oth operators are adjacent
    to b, so we must take associativity into account. Assigment opeators group
    from right to left, so parentheses go around the += expression first, then
    the = expression.
    #+BEGIN_SRC C
    (a = (b += (((c++) - d) + ((--e) / (-f)))));
    #+END_SRC
    The expression is now fully parenthesized.



* Chapter 7
** limits.h
   #+BEGIN_SRC C
   
   #include <stdio.h>
   #include <limits.h>

   int main() {

   printf("The number of bits in a byte %d\n", CHAR_BIT);

   printf("The minimum value of SIGNED CHAR = %d\n", SCHAR_MIN);
   printf("The maximum value of SIGNED CHAR = %d\n", SCHAR_MAX);
   printf("The maximum value of UNSIGNED CHAR = %d\n", UCHAR_MAX);

   printf("The minimum value of SHORT INT = %d\n", SHRT_MIN);
   printf("The maximum value of SHORT INT = %d\n", SHRT_MAX); 

   printf("The minimum value of INT = %d\n", INT_MIN);
   printf("The maximum value of INT = %d\n", INT_MAX);

   printf("The minimum value of CHAR = %d\n", CHAR_MIN);
   printf("The maximum value of CHAR = %d\n", CHAR_MAX);

   printf("The minimum value of LONG = %ld\n", LONG_MIN);
   printf("The maximum value of LONG = %ld\n", LONG_MAX);
  
   return(0);
}
   #+END_SRC

   #+RESULTS:
   | The | number  | of    | bits | in       | a    |                   byte |      8 |
   | The | minimum | value | of   | SIGNED   | CHAR |                      = |   -128 |
   | The | maximum | value | of   | SIGNED   | CHAR |                      = |    127 |
   | The | maximum | value | of   | UNSIGNED | CHAR |                      = |    255 |
   | The | minimum | value | of   | SHORT    | INT  |                      = | -32768 |
   | The | maximum | value | of   | SHORT    | INT  |                      = |  32767 |
   | The | minimum | value | of   | INT      | =    |            -2147483648 |        |
   | The | maximum | value | of   | INT      | =    |             2147483647 |        |
   | The | minimum | value | of   | CHAR     | =    |                   -128 |        |
   | The | maximum | value | of   | CHAR     | =    |                    127 |        |
   | The | minimum | value | of   | LONG     | =    | -9.223372036854776e+18 |        |
   | The | maximum | value | of   | LONG     | =    |  9.223372036854776e+18 |        |

** ctype.h
   The header ctype.h in the ANSI C Standard Library for the C programming language contains declarations for character    classification functions.
   List of ctype.h header fileâ€™s library functions with explanation and example programs
    1. isalnum
      #+BEGIN_SRC C
      /* This function checks whether character is alphanumeric or not.*/
      #include<stdio.h>
      #include<ctype.h>
      int main (void) {
       char ch;
       
       printf("Enter a character: ");
       scanf("%c", &ch);

       if (isalnum(ch))
          printf("%c is an alphanumeric character.\n",ch);
       else
          printf("%c is not an alphanumeric character.\n",ch);
       

       return 0;
      }
      
      #+END_SRC
    2. 
            
** Exercises
*** Section 7.1
    1. Give thew decimal value of eaxch of the following integer constants:
       a) 077 ---> 7*8^0 + 7*8^1 --> 63
       b) 0x77---> 7*16^0 + 7*16^1 --> 119
       c) 0XABC ---> 10*16^2+11*16^1+12*16^0 ---> 2560+176+12 = 2748
       #+BEGIN_SRC C
       /* Give the value of each of the following integer constants.
        * (a) 077
        * (b) 0x77
        * (c) 0XABC
        */
        #include <stdio.h>

        int main(void)
        {
         printf("\nA: %d\n", 077);
         printf("B: %d\n", 0x77);
         printf("C: %d\n\n", 0XABC);
         return 0;
}

       #+END_SRC

       #+RESULTS:
       | A: |   63 |
       | B: |  119 |
       | C: | 2748 |

*** Section 7.2

    2. Which of the following are not legal constants in C? Classify each legal constant as either integer or floating-point.
       a) 010E2 ----> Integer
       b) 32.1E+5---> Floating-point
       c) 0790 -----> Not legal. 9 is not octal digit number.
       d) 100_000 --> Not legal. underscores are not legal.
       e) 3.978e-2--> Floating-point

       #+BEGIN_SRC C
       
       #include<stdio.h>
       int main (void) {

        printf("\na): %f\n", 0102E2);
        printf("b): %f\n", 32.1E+5);
        /* printf("c): %d", 0790); */
        /* printf("d): %f", 100_000); */
        printf("e): %f\n", 3.987e-2);
        
        return 0;
       }
       #+END_SRC

       #+RESULTS:
       | a): |   10200.0 |
       | b): | 3210000.0 |
       | e): |   0.03987 |
     3. Which of the following are not legal types in C:
	a) short unsigned int  
	b) short float           ---> Not legal
	c) long double           
	d) unsigned long         

        #+BEGIN_SRC C 
        #include <stdio.h>

        int main(void)
        {
          short unsigned int a;
          /* short float b; */
          long double c;
          unsigned long d;

          return 0;
         }

/* Answer:
 * A - legal
 * B - illegal
 * C - legal
 * D - legal
 */

        #+END_SRC

        #+RESULTS:

*** Section 7.3
    
    4. If c is a variable of type char, which one of the following statements is illegal?
       (a) i += c; /* i has type int */
       (b) c = 2 * c = 1;
       (c) putchar(c);
       (d) printf(c);

       Answer: (d) is illegal because printf requires a string

    5. Which one of the following is not a legal way to write the number 65? (Assume that the character set is ASCII.)

       (a) 'A'
       (b) 0b1000001
       (c) 0101
       (d) 0x41

       #+BEGIN_SRC C

       #include<stdio.h>

       int main(void) {
       
       int a = 'A';
       int b = 0b1000001;
       int c = 0101;
       int d = 0x41;

       printf("\nA: %d\n", a);
       printf("B: %d\n", b);
       printf("C: %d\n", c);
       printf("D: %d\n", d);

       }
       
       #+END_SRC

       #+RESULTS:
       | A: | 65 |
       | B: | 65 |
       | C: | 65 |
       | D: | 65 |

    6. For each of the following items of data, specify which one of the types char, short, int or long is the smallest one guaranteed to be large enough to store the item.

       (a) Days in a month.
       (b) Days in a year.
       (c) Minutes in a day.
       (d) Seconds in a day.

       Answer:
       a) char
       b) short
       c) short
       d) int

    7. For each of the following character escapes, give the equivalent octal escape. (Assume that the character set is ASCII.) You may wish to consult Appendix E, which lists the numerical codes for ASCII characters.

       (a) \b
       (b) \n
       (c) \r
       (d) \t

       Answer:
       a) backspace:         \010
       b) new linefeed:      \012
       c) carriage return:   \015
       d) horizontal tab:    \011

    8. Repeat Exercise 7, but give the equivalent hexadecimal escape

       Answer:
       a) \0x8
       b) \0xA
       c) \0xD
       d) \0x9

    9. Suppose that i and j are variables of type int. What is the type of the expression i / j + 'a'?
       
       Answer:
       The expression will be an int. the short type is promote to int.

*** Section 7.4

    10. Suppose that i is a variable of type int, j is a variable of type long, and k is a variable of type unsigned int. What is the type of the expression i + (int) j * k

Answer:
j is first explicitly converted from a long to an int.
Then the expression becomes (int) + (int) * (unsigned int). Which is much more
simple.

The expression should evaluate to unsigned int in the end.

    11. Suppose that i is a variable of type int, f is a variable of type float, and d is a variable of type double. What is the type of the expression i * f / d?

Answer:
i * f is float type.
i * f / d is finally as a double.

    12. Suppose that i is a variable of type int, f is a variable of type float, and d is a variable  of type double. Explain what conversions take place during the execution of the following statement: 
d = i + f;

Answer:
In the statement, i is converted to a float, then the result of i + f is
converted to a double in the end.

    13. Assume that a program contains the following declarations:

	char c = '\1';
	short s = 2;
	int i = -3;
	long m = 5;
	float f = 6.5f;
	double d = 7.5;

	Give the value and the type of each expression listed below:
	(a) c * i;
	(b) s + m;
	(c) f / c
	(d) d / s
	(e) f - d
	(f) (int) f

    Answer:
    a) int;
    b) long
    c) float
    d) double
    e) double
    f) int

    14. Does the following statement always compute the fractional part of f correctly (assuming that f and frac_part are float variables)?
	frac_part = f - (int) f;
	#+BEGIN_SRC C

	#include <stdio.h>

	int main(void)
	{
	float f, fract_part;
	
	printf("\nEnter a fractional number (e.g. 1.55): ");
	scanf("%f", &f);
	
	fract_part = f - (int) f;
	printf("Fractional part: %f\n\n", fract_part);
	
	return 0;
	}

	
	#+END_SRC

	Answer:
	No, it will fail if the value of f exceeds the largest value of an int.
*** Section 7.5
    15. Use typedef to create types named Int8, Int16, and Int32. Define the types so that they represent 8-bit, 16-bit, and 32-bit integers on your machine.

    #+BEGIN_SRC C
    #include <stdio.h>
    #include <stdint.h>

    int main(void) {
    
     typedef int8_t Int8;
     typedef int16_t Int16;
     typedef int32_t Int32;

     printf("\nSize of Int8: %d bits\n", sizeof(Int8) * 8);
     printf("Size of Int16: %d bits\n", sizeof(Int16) * 8);
     printf("Size of Int32: %d bits\n", sizeof(Int32) * 8);

     return 0;
    }
    
    #+END_SRC

    #+RESULTS:
    | Size | of | Int8:  |  8 | bits |
    | Size | of | Int16: | 16 | bits |
    | Size | of | Int32: | 32 | bits |

