* The message function examples

  (message "The name of this buffer is : %s" (buffer-name))

  (message "The value of fill-column is %d. " fill-column)  

  (message "The are %d %s in the office" (- fill-column 14) "pink elephants")

  finally, here is a somewhat complex example

  (message "He saw %d %s"
            (- fill-column 32)
	    (concat "red " 
	            (substring
		     "The quick brown foxes jumped," 16 21)
		     " leaping."))
 
** Setting the Value of a Variable
*** Using set
    (set 'flowers '(rose violet daisy buttercup)) 
*** Using setq
    (setq carnivores '(lion tiger leopard))
    (setq trees '(pine oak maple)
          hervibores '(gazelle antelope zebra))
*** Counting
    (setq counter 0)                  ; Let's call this initializer
    (setq counter (+ counter 1))      ; This is the increment
** Exercises
   ;; Create a counter that increments by two rather than one
   (setq counter-two 0)
   (setq counter-two (+ counter-two 2))
   ;; Write an expression that prints a message in the echo area when evaluated
   (message "The counter has a value %d" counter-two)
* Practicing evaluation
** Buffer Names
   (buffer-name)
   (buffer-file-name)
** Getting Buffers
   (current-buffer)
   (other-buffer)
** Switching Buffers
   (switch-to-buffer (other-buffer))
** Buffer Size and the Location of Point
   (buffer-size)      ; returns a count of the number of characters in the buffer
   (point)
   (point-min)
   (point-max)
** Exercise
* How to write functions definitions   

  #+BEGIN_SRC emacs-lisp
  (defun mark-whole-buffer ()
  "Put point at beginning and mark at end of buffer.
If narrowing is in effect, only uses the accessible part of the buffer.
You probably should not use this function in Lisp programs;
it is usually a mistake for a Lisp function to use any subroutine
that uses or sets the mark."
  (declare (interactive-only t))
  (interactive)
  (push-mark)
  (push-mark (point-max) nil t)
  ;; This is really `point-min' in most cases, but if we're in the
  ;; minibuffer, this is at the end of the prompt.
  (goto-char (minibuffer-prompt-end)))

  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (defun multiply-by-seven (number)
     "Multiply NUMBER by seven"
     (* 7 number))
  #+END_SRC
  #+BEGIN_SRC emacs-lisp
  (multiply-by-seven 30)
  #+END_SRC

  #+RESULTS:
  : 210
** Make a Function Interactive
  #+BEGIN_SRC emacs-lisp
  (defun multiply-by-seven (number)
     "Multiply NUMBER by seven"
     (interactive "p")
     (message "The result is %d" (* 7 number)))
  #+END_SRC

  #+RESULTS:
  : multiply-by-seven

** let
   #+BEGIN_SRC emacs-lisp
     (let ((zebra "stripes")
           (tiger "fierce"))
       (message "One kind of animal has %s and another is %s."
                zebra tiger))
   #+END_SRC

   #+RESULTS:
   : One kind of animal has stripes and another is fierce.
** if in more detail
   #+BEGIN_SRC emacs-lisp
   
     (defun type-of-animal (characteristic)
       "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the string \"fierce\",
     then warn of a tiger."
       (if (equal characteristic "fierce")
              (message "It is a tiger!") 
          (message "It is not fierce!")))
   #+END_SRC

   #+RESULTS:
   : type-of-animal
   #+BEGIN_SRC emacs-lisp
   (type-of-animal "fierce")
   #+END_SRC

   #+RESULTS:
   : It is a tiger!
   #+BEGIN_SRC emacs-lisp
   (type-of-animal "striped")
   #+END_SRC
   #+RESULTS:
   : It is not fierce!
** 3.12 Exercises
   • Write a non-interactive function that doubles the value of its
     argument, a number.  Make that function interactive.
#+BEGIN_SRC emacs-lisp
(defun make-double (number)
   (message "The double of %d is: %d" number (* 2 number)))
(make-double 16)
#+END_SRC

#+RESULTS:
: The double of 16 is: 32
#+BEGIN_SRC emacs-lisp
(defun make-double (number)
   (interactive "p")
   (message "The double of %d is: %d" number (* 2 number)))

#+END_SRC

#+RESULTS:
: make-double
   • Write a function that tests whether the current value of
     ‘fill-column’ is greater than the argument passed to the function,
     and if so, prints an appropriate message.

#+BEGIN_SRC emacs-lisp
(defun curr-col (number)
(if (> number fill-column)
    (message "The number %d is greater than %d" number fill-column)
  (message "The number %d is less than %d" number fill-column))) 
#+END_SRC
#+BEGIN_SRC emacs-lisp
(curr-col 67)
#+END_SRC

#+RESULTS:
: The number 67 is less than 80

#+BEGIN_SRC emacs-lisp
(curr-col 85)
#+END_SRC

#+RESULTS:
: The number 85 is greater than 80
* A Few Buffer-Related Functions

